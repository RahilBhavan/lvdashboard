// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/// @title ZkVerifier
/// @notice Cryptographically verifies that tick ranges were generated by authorized keeper
/// @dev Uses ECDSA signatures. Can be upgraded to ZK-SNARKs (Axiom/Brevis) in future
contract ZkVerifier {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;
    
    address public trustedSigner;
    mapping(bytes32 => bool) public usedProofs;
    
    event ProofVerified(bytes32 indexed proofHash, address signer, bool success);
    event SignerUpdated(address indexed oldSigner, address indexed newSigner);
    
    error InvalidSignature();
    error ProofAlreadyUsed();
    error InvalidSigner();
    
    constructor(address _trustedSigner) {
        if (_trustedSigner == address(0)) revert InvalidSigner();
        trustedSigner = _trustedSigner;
    }
    
    /// @notice Verifies that tick ranges were signed by trusted keeper
    /// @param proof ECDSA signature of (tickLower, tickUpper, blockNumber)
    /// @param tickLower The proposed lower tick
    /// @param tickUpper The proposed upper tick
    /// @return valid True if signature is valid and from trusted signer
    function verify(
        bytes calldata proof,
        int24 tickLower,
        int24 tickUpper
    ) external returns (bool valid) {
        // Prevent empty proofs
        if (proof.length == 0) {
            return false;
        }
        
        // Create message hash from parameters + recent block
        // This prevents replay attacks and ensures freshness
        bytes32 messageHash = keccak256(
            abi.encodePacked(tickLower, tickUpper, block.number)
        );
        
        // Check if proof already used (prevent replay)
        bytes32 proofHash = keccak256(proof);
        if (usedProofs[proofHash]) {
            revert ProofAlreadyUsed();
        }
        
        // Convert to Ethereum signed message hash
        bytes32 ethSignedHash = messageHash.toEthSignedMessageHash();
        
        // Recover signer from signature
        address signer = ethSignedHash.recover(proof);
        
        // Validate signer
        bool isValid = (signer == trustedSigner);
        
        if (isValid) {
            // Mark proof as used
            usedProofs[proofHash] = true;
        }
        
        emit ProofVerified(proofHash, signer, isValid);
        return isValid;
    }
    
    /// @notice Updates the trusted signer address
    /// @dev Only callable by current signer (self-sovereign)
    function updateSigner(address newSigner, bytes calldata signature) external {
        if (newSigner == address(0)) revert InvalidSigner();
        
        bytes32 messageHash = keccak256(abi.encodePacked(newSigner, block.chainid));
        bytes32 ethSignedHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedHash.recover(signature);
        
        if (signer != trustedSigner) revert InvalidSignature();
        
        emit SignerUpdated(trustedSigner, newSigner);
        trustedSigner = newSigner;
    }
}
